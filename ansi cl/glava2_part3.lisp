;;---------------------------------------------------
;; remove - принимает список и объект и возвращает новый
;; список, из которого исключён данный объект

(setf lst '(c a r a t))

;; => (C A R A T)

(remove 'a lst)

;; => (C R T)

lst

;; => (C A R A T)
;; сам список не меняется

(setf lst (remove 'a '(c a r a t)))

;; => (C R T)

lst

;; => (C R T)
;; список меняется, так как сначала выполняется
;; remove, а уже потом - let

;;---------------------------------------------------
;; do - основной итерационный оператор
;; Первый аргумент задаёт переменные (variable initial update)
;; variable - символ
;; initial - выражение, задающее исходное значение
;; update - выражение, задающее изменение initial
;; при каждой итерации
;; Второй аргумент - список, определяющий, когда итерация
;; должна остановиться (проверка)
;; Остальные выражения будут выполнены после каждой итерации
;; (это тело цикла)

(defun show-squares (start end)
  (do ((i start (+ i 1)))
      ((> i end) 'done)
    (format t "~A ~A~%" i (* i i))))

;; => SHOW-SQUARES
;; Переменные функции show-squares - это start и end
;; Для каждого i начиная со start, а затем для i+1
;; и далее выполнять проверку - если i меньше end,
;; печатается i и i*i, а если i больше end - выводится
;; done, т. е. "сделано"

(show-squares 3 8)

;; CL-USER> (show-squares 3 8)
;; 3 9
;; 4 16
;; 5 25
;; 6 36
;; 7 49
;; 8 64
;; DONE

;;---------------------------------------------------
;; progn - принимает любое количество выражений, вычисляет их
;; одно за другим и возвращает значение последнего

(defun show-squares (i end)
  (if (> i end)
      'done
       (progn
         (format t "~A ~A~%" i (* i i))
         (show-squares (+ i 1) end))))

;; => SHOW-SQUARES

;; Аргументы функции - i и end (i - переменная)
;; Если i больше end - вывести done
;; Иначе - напечатать i и i*i, а потом выполнить
;; всё сначала от i+1 до end

;;---------------------------------------------------
;; dolist - принимает первый аргумент вида (variable expression)
;; и следующий за ним набор выражений

(defun our-length (lst)
  (let ((len 0))
    (dolist (obj lst)
      (setf len (+ len 1)))
    len))

;; => OUR-LENGTH
;; Аргумент функции our-length - список
;; Вводится локальная переменная len=0
;; Для каждого объекта списка присваивается
;; len, len+1, и после прохода по всем объектам
;; выводится последнне вычисленное len

(our-length '(1 4 6 3 4))

;; => 5

(our-length '("кошка" 4 6 'дерево 'a '(1 2)))

;; => 6

;;---------------------------------------------------
;; function (#')- специальный оператор, даёт имя функции

(function +)

;; => #<FUNCTION +>

#'+

;; => #<FUNCTION +>

;;---------------------------------------------------
;; apply - её арументами являются функция и список её аргументов,
;; в этом случае она возвращает результат вызова этой функции
;; с заданными аргументами (последний должен быть списком)

(apply #'+ '(1 2 3))

;; => 6

(apply #'+ 1 2 '(3 4 5))

;; => 15

;;---------------------------------------------------
;; funcall - функция, аналогичная apply, но не требующая,
;; чтобы аргументы были упакованы в список

(funcall #'+ 1 2 3)

;; => 6

;;---------------------------------------------------
;; lambda - позволяет задавать функцию буквально
;; Лямбда-выражени - это список, содержащий символ lambda
;; и следующие за ним аргументы и тело

(lambda (x y)
  (+ x y))

;; => #<FUNCTION (LAMBDA (X Y)) {CD65BFD}>

((lambda (x) (+ x 100)) 1)

;; => 101

(funcall #'(lambda (x) (+ x 100))
           1)

;; => 101

;;---------------------------------------------------
;; typep - определяет, принадлежит ли её первый арумент
;; к указанному типу

(typep 27 'integer)

;; => T

(typep 27 'string)

;; => NIL

(typep "27" 'string)

;; => T







