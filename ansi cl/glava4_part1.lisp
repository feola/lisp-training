;;---------------------------------------------------
;; make-array - позволяет создавать массивы

(setf arr (make-array '(2 3) :initial-element nil))

;; => #2A((NIL NIL NIL) (NIL NIL NIL))
;; Получается массив 2х3, состоящий из nil

;; :initial-element - это аргумент (не обязательный)
;; Если он используется, задаётся начальное значение каждого
;; элемента массива (в данном примере nil)

;;---------------------------------------------------
;; aref - позволяет получить элемент массива (отсчёт начинается с нуля)

(aref arr 0 0)

;; => NIL

;;---------------------------------------------------
;; Чтобы установить новое значение массива, необходимо использовать
;; setf вместе с aref

(setf (aref arr 0 0) 'b)

;; => B

(aref arr 0 0)

;; => B

;;---------------------------------------------------
;; Массив можно задать с помощью синтаксиса #na
;; n - количество размерностей массива

#2a((b nil nil) (nil nil nil))

(setf *print-array* t)

;; => T
;; *print-array* - глобальная переменная (если она Т, то массив будет
;; напечатан в заданном виде)

arr

;; => #2A((B NIL NIL) (NIL NIL NIL))

;;---------------------------------------------------
;; Чтобы создать одномерный массив (вектор), можно передать функции
;; make-array в качестве аргумента целое число

(setf vec (make-array 4 :initial-element nil))

;; => #(NIL NIL NIL NIL)

;;---------------------------------------------------
;; vector - позволяет создать и заполнить вектор

(vector "a" 'b 3)

;; => #("a" B 3)

;; Также вектор можно задать сразу с помощью синтаксиса #()

#("a" b 3)

;; => #("a" B 3)

#(1 2 a)

;; => #(1 2 A)

;;---------------------------------------------------
;; Доступ к элементам вектора можно осуществлять как aref,
;; так и svref (это более быстрый способ)
;; "sv" - "simple vector"

(svref vec 0)

;; => NIL

(setf my-vec #(1 2 a))

;; => #(1 2 A)

(svref my-vec 1)

;; => 2

;;---------------------------------------------------
;; Для примера можно рассмотреть функцию, которая ищет элемент в
;; отсортированном векторе

(defun bin-search (obj vec)
  (let ((len (length vec)))
    (and (not (zerop len))
         (finder obj vec 0 (- len 1)))))

;; => BIN-SEARCH

(defun finder (obj vec start end)
  (let ((range (- end start)))
    (if (zerop range)
        (if (eql obj (aref vec start))
            obj
            nil)
        (let ((mid (+ start (round (/ range 2)))))
          (let ((obj2 (aref vec mid)))
            (if (< obj obj2)
                (finder obj vec start (- mid 1))
                (if (> obj obj2)
                    (finder obj vec (+ mid 1) end)
                    obj)))))))

;; => FINDER

(bin-search 3 #(0 1 2 3 4 5 6 7 8 9))

;; => 3

(bin-search 7 #(3 6 1 2 7 8 1))

;; => 7

(bin-search 7 #(3 6 1 2 7 9 1))

;; => NIL

;; Обнаружила, что функция не работает, если в векторе рядом с искомым элементом
;; (с любой стороны) идёт элемент, который превышает его более, чем на 2


