;;---------------------------------------------------
;; УПРАЖНЕНИЯ
;;---------------------------------------------------

;;---------------------------------------------------
;; 1. Представьте следующие списки в виде ячеек

(a b (c d))

;; |---|---|   |---|---|   |---|---|
;; | a |   | > | b |   | > |   |nil|
;; |---|---|   |---|---|   |---|---|
;;                           |
;;                           |
;;                         |---|---|   |---|---|
;;                         | c |   | > | d |nil|
;;                         |---|---|   |---|---|

(a (b (c (d))))

;; |---|---|   |---|---|
;; | a |   | > |   |nil|
;; |---|---|   |---|---|
;;               |
;;               |
;;             |---|---|   |---|---|
;;             | b |   | > |   |nil|
;;             |---|---|   |---|---|
;;                           |
;;                           |
;;                         |---|---|   |---|---|
;;                         | c |   | > |   |nil|
;;                         |---|---|   |---|---|
;;                                       |
;;                                       |
;;                                     |---|---|
;;                                     | d |nil|
;;                                     |---|---|

(((a b) c) d)

;; |---|---|   |---|---|
;; |   |   | > | d |nil|
;; |---|---|   |---|---|
;;   |
;;   |
;; |---|---|   |---|---|
;; |   |   | > | c |nil|
;; |---|---|   |---|---|
;;   |
;;   |
;; |---|---|   |---|---|
;; | a |   | > | b |nil|
;; |---|---|   |---|---|

(a (b . c) . d)

;; |---|---|---|
;; | a |   | d |
;; |---|---|---|
;;       |
;;       |
;;     |---|---|
;;     | b | c |
;;     |---|---|

;;---------------------------------------------------
;; 2. Напишите свой вариант функции union, который сохраняет порядок следования
;; элементов согласно исходным спискам

(defun my-union (a b)
  (if (null b)
      a
      (my-union (reverse (adjoin (car b) (reverse a)))
                (cdr b))))

(my-union '(a f c) '(b c d))

;; => (A F C B D)

(my-union '(a b c) '(d c e a f))

;; => (A B C D E F)

(my-union '(3 4 5) '(1 2 3 4 6))

;; => (3 4 5 1 2 6)

;;---------------------------------------------------
;; 3. Напишите функцию, определяющую количество повторений (с точки зрения eql)
;; каждого элемента в заданном списке и сортирующую их по убыванию встречаемости

;; Пока не получается

;;---------------------------------------------------
;; 4. Почему (member '(a) '((a) (b))) возвращает nil?

(member '(a) '((a) (b)))

;; => NIL

;; Потому что с точки зрения eql (a) и (a) не равны, они соответствуют
;; в памяти лиспа разным объектам

(eql '(a) '(a))

;; => NIL

;; Чтобы выполнить сравнение, необходимо добавить ключ

(member '(a) '((a) (b)) :test #'equal)

;; => ((A) (B))

;;---------------------------------------------------
;; 5. Функция pos+ принимает список и возвращает новый, каждый элемент
;; которого увеличен по сравнению с исходным на его положение в списке
;; Определите функцию с помощью (a) рекурсии, (b) итерации и (c) mapcar

;; a - рекурсия
;; Работает наоборот - прибавляет позицию в обратном порядке
;; Надо думать, как исправить

(defun a-pos+ (lst)
  (if (not (null lst))
      (cons (+ (car lst) (length (cdr lst)))
            (a-pos+ (cdr lst)))
      lst))

(a-pos+ '(1 1 1 1))

;; => (4 3 2 1)

;; b - итерация
;; Всё работает правильно

(defun b-pos+ (lst)
  (let (x)
    (dolist (obj lst x)
      (setf x (cons (+ obj (length x)) x)))
    (reverse x)))

(b-pos+ '(1 1 1 1))

;; => (1 2 3 4)

;; c - mapcar
;; Работает только для списка с ограниченным количеством элементов
;; Надо думать, как сделать для списка с любым количеством элементов

(defun c-pos+ (lst)
  (mapcar #'+ '(0 1 2 3) lst))

(c-pos+ '(1 1 1 1))

;; => (1 2 3 4)

