;;---------------------------------------------------
;; ДОСТУП
;;---------------------------------------------------
;; nth - позволяет получить элемент списка с определённым индексом

(nth 0 '(a b c))

;; => A

(nth 3 '(34 45 12 90))

;; => 90

;;---------------------------------------------------
;; last - возвращает последнюю cons-ячейку списка

(last '(a b c))

;; => (C)

(car (last '(a b c)))

;; => C

;;---------------------------------------------------
;; zerop - проверяет, равен ли 0 её арумент

(zerop 2)

;; => NIL

(zerop (- 3 3))

;; => T

;;---------------------------------------------------
;; nthcdr - позволяет получить n-ый хвост списка

(nthcdr 2 '(a b c))

;; => (C)

(nthcdr 2 '(2 (6 9) 3 (4 6 7)))

;; => (3 (4 6 7))

;; Можно определить функцию nthcdr

(defun our-nthcdr (n lst)
  (if (zerop n)
      lst
      (our-nthcdr (- n 1) (cdr lst))))

;; => OUR-NTHCDR

;; Функция принимает 2 арумента (n - номер элемента, и список)
;; Если номер элемента равен 0, вывести список
;; Иначе применить функцию our-nthcdr для номера n-1 и хвоста списка

(our-nthcdr 3 '(a b c d e f))

;; => (D E F)

;;---------------------------------------------------
;; ОТОБРАЖАЮЩИЕ ФУНКЦИИ
;;---------------------------------------------------
;; mapcar - вызывает заданную функцию поэлементно для одного
;; или нескольких списков и возвращает список результатов

(mapcar #'(lambda (x) (+ x 10))
          '(1 2 3))

;; => (11 12 13)

(mapcar #'list
          '(a b c)
           '(1 2 3 4))

;; => ((A 1) (B 2) (C 3))

(mapcar #'cdr  '((3 4) (5 6)))

;; => ((4) (6))

;;---------------------------------------------------
;; maplist - применяет функцию последовательно к cdr списка,
;; начиная со всего списка целиком

(maplist #'(lambda (x) x)
           '(a b c))

;; => ((A B C) (B C) (C))

;;---------------------------------------------------
;; ДЕРЕВЬЯ
;;---------------------------------------------------
;; cons-ячйки можно рассматривать как двоичные деревья
;; car - правое поддерево, cdr - левое поддерево
;;---------------------------------------------------
;; copy-tree - принимает дерево и возвращает его копию

(copy-tree '(a (b c) d))

;; => (A (B C) D)

;; Можно определить эту функцию

(defun our-copy-tree (tr)
  (if (atom tr)
      tr
      (cons (our-copy-tree (car tr))
            (our-copy-tree (cdr tr)))))

;; => OUR-COPY-TREE

;; Если список tr является атомом, вывести tr
;; Иначе создать cons-ячейку из результатов вызова
;; функции our-copy-tree для головы и хвоста списка

;; Деревья удобны для работы со списками и подсписками
;; Например, можно заменить элементы в последовательности
;; с помощью функции substitute

(and (integerp x) (zerop (mod x 2)))

(substitute 'y 'x '(and (integerp x) (zerop (mod x 2))))

;; => (AND (INTEGERP X) (ZEROP (MOD X 2)))

;; Данный пример не дал результатов, так как в представленной
;; последовательности нет одиночного элемента х

;; Похожая функция subst позволяет работать с деревьями

(subst 'y 'x '(and (integerp x) (zerop (mod x 2))))

;; => (AND (INTEGERP Y) (ZEROP (MOD Y 2)))

;; Можно определить функцию subst

(defun our-subst (new old tree)
  (if (eql tree old)
      new
      (if (atom tree)
          tree
          (cons (our-subst new old (car tree))
                (our-subst new old (cdr tree))))))

;; => OUR-SUBST

;; Функция принимает 3 аргумента
;; new - новый аргумент (тот, на который необходимо заменить)
;; old - старый аргумент (тот, который необходимо заменить)
;; tree - дерево (список, последовательность элементов)
;; Если последовательность равна старому аргументу, выводится новый арумент
;; Иначе, если tree является атомом, выводится tree
;; Если нет, составляется cons-ячейка из результатов вызова функции our-subst
;; для головы и хвоста tree
;; Такая рекурсия, когда функция вызывает себя с car и cdr, называется двоичной




