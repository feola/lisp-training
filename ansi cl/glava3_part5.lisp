;;---------------------------------------------------
;; СТОПКА (stack)
;;---------------------------------------------------
;; (push x y) - кладёт объект x на вершину стопки y
;; (push obj lst) -> (setf lst (cons obj lst))

(setf x '(b))

;; => (B)

(push 'a x)

;; => (A B)

x

;; => (A B)

;; С помощью push можно итеративно определить функцию revers

(defun our-reverse (lst)
  (let ((acc nil))
    (dolist (elt lst)
      (push elt acc))
    acc))

;; => OUR-REVERSE

;; Задаётся локальная переменная acc, в начале соответствующая nil
;; Для каждого элемента списка необходимо положить этот элемент
;; на acc и вывести acc
;; То есть берётся первый элемент, перед ним ставится следующий
;; и так далее. В результате список как бы "отзеркаливается"

;;---------------------------------------------------
;; (pop x) - снимет со стопки верхний элемент
;; (pop lst)
;; -> (let ((x (car lst))
;;          (setf lst (cdr lst))
;;          x)

(setf y x)

;; => (A B)

(pop x)

;; => A

x

;; => (B)

y

;; => (A B)

;;---------------------------------------------------
;; pushnew - макрос, похожий на push, но использующий adjoin
;; вместо cons

(let ((x '(a b)))
  (pushnew 'c x)
  (pushnew 'a x)
  x)

;; => (C A B)

;; Сначала задаётся локальная переменная x, равная списку (a b)
;; pushnew добавляет c, а потом а
;; Но а в списке уже есть, поэтому результат - (C A B)

;;---------------------------------------------------
;; ТОЧЕЧНЫЕ ПАРЫ
;;---------------------------------------------------
;; Правильные списки (proper-list) - это nil, либо cons-ячейка,
;; cdr которой - также правильный список
;; Точечная пара - это структура, содержащая ровно 2 элемента

;; Можно определить функцию, которая проверяет, является ли аргумент
;; правильным списком

(defun proper-list? (x)
  (or (null x)
      (and (consp x)
           (proper-list? (cdr x)))))

;; => PROPER-LIST?

;; Аргумент (x) является правильным списком, если список пустой
;; Либо если одновременно выполняются 2 условия
;; x - cons-ячейка
;; результат вызова proper-list? для хвоста списка - nil
;; или cons-ячейка

(proper-list? '(a b c))

;; => T

(setf pair (cons 'a 'b))

;; => (A . B)
;; Получилась ячейка - точечная пара, так как cons объединил 2 элемента
;; |---|---|
;; | a | b |
;; |---|---|

;; Правильные списки можно создавать с помощью точечных пар

'(a . (b . (c . nil)))

;; => (A B C)

;; Также допустима смешанная форма записи

(cons 'a (cons 'b (cons 'c 'd)))

;; => (A B C . D)

;; Четыре способа задания списка (a b)

'(a . (b . nil))

;; => (A B)

'(a . (b))

;; => (A B)

'(a b . nil)

;; => (A B)

'(a b)

;; => (A B)

;;---------------------------------------------------
;; АССОЦИАТИВНЫЕ СПИСКИ
;;---------------------------------------------------
;; Ассоциативные списки (assoc-list) - это списки точечных пар
;; С их помощью удобно определять какие-либо правила или соответствия

(setf trans '((+ . "add") (- . "subtract")))

;; => ((+ . "add") (- . "subtract"))

;;---------------------------------------------------
;; assoc - функция для получения по ключу соответствующей ему пары

(assoc '+ trans)

;; => (+ . "add")

(assoc '* trans)

;; => NIL

;; Можно определить упрощённый вариант функции assoc

(defun our-assoc (key alist)
  (and (consp alist)
       (let ((pair (car alist)))
         (if (eql key (car pair))
             pair
             (our-assoc key (cdr alist))))))

;; => OUR-ASSOC

;; Список должен быть cons-ячейкой
;; Задаётся локальная переменная pair, равная голове списка
;; Если ключ равен голове списка, возвращается pair
;; Иначе вызывается функция our-assoc для хвоста списка

;; Существует также функция assoc-if (по аналоии с member-if)

;;---------------------------------------------------
;; ПРИМЕР: ПОИСК КРАТЧАЙШЕГО ПУТИ
;;---------------------------------------------------
;; Мохно составить программу, которая вычисляет наикратчайший путь на графе

(setf min '((a b c) (b c) (c d)))

;; => ((A B C) (B C) (C D))

(cdr (assoc 'a min))

;; => (B C)

(defun shortest-path (start end net)
  (bfs end (list (list start)) net))

;; => SHORTEST-PATH

;; Функция shortest-path принимает 3 аргумента
;; start - 1-ый узел (от которого начинается путь)
;; end - последний узел (которым заканчивается путь)
;; net - сеть (граф)
;; shortest-path выполняет функцию bfs для end,
;; (list (list start)) и net

(defun bfs (end queue net)
  (if (null queue)
      nil
      (let ((path (car queue)))
        (let ((node (car path)))
          (if (eql node end)
              (reverse path)
              (bfs end
                   (append (cdr queue)
                           (new-paths path node net))
                   net))))))

;; => BFS

;; Функция принимает 3 аргумента - end, queue и net
;; queue - это очередь, то есть путь к узлу
;; Начинаем с первого узла - это а, путь к нему один,
;; это (list (list start)), то есть ((А))
;; Идёт проверка на то, является ли queue пустым списком
;; Если да - то будет выведен nil, так как надо прийти в
;; последний узел, но в данном случае путь не найден, очередь пуста
;; Если список не пустой, задаются локальные переменные
;; (path (car queue)) и (node (car path))
;; Если node равно end, выполняется reverse для path, то есть
;; переворачивается порядок элементов в path
;; Иначе вызывается bfs для end, net и склеенного списка
;; Список склеивается из хвоста queue и результата вызова функции
;; new-paths для path, node и net

(defun new-paths (path node net)
  (mapcar #'(lambda (n)
              (cons n path))
            (cdr (assoc node net))))

;; => NEW-PATHS

;; new-paths убирает голову части net, в которой есть node
;; и составляет с результатом и path ячейку





